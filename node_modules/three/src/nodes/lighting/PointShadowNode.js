import ShadowNode from './ShadowNode.js';
import { uniform } from '../core/UniformNode.js';
<<<<<<< HEAD
import { float, vec3, If, Fn } from '../tsl/TSLBase.js';
import { reference } from '../accessors/ReferenceNode.js';
import { cubeTexture } from '../accessors/CubeTextureNode.js';
import { renderGroup } from '../core/UniformGroupNode.js';
import { Matrix4 } from '../../math/Matrix4.js';
import { Vector3 } from '../../math/Vector3.js';
import { Color } from '../../math/Color.js';
import { BasicShadowMap, LessCompare, WebGPUCoordinateSystem } from '../../constants.js';
import { CubeDepthTexture } from '../../textures/CubeDepthTexture.js';
import { screenCoordinate } from '../display/ScreenNode.js';
import { interleavedGradientNoise, vogelDiskSample } from '../utils/PostProcessingUtils.js';
import { abs, normalize, cross } from '../math/MathNode.js';

const _clearColor = /*@__PURE__*/ new Color();
const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3();
const _lookTarget = /*@__PURE__*/ new Vector3();

// Cube map face directions and up vectors for point light shadows
// Face order: +X, -X, +Y, -Y, +Z, -Z
// WebGPU coordinate system - Y faces swapped to match texture sampling convention
const _cubeDirectionsWebGPU = [
	/*@__PURE__*/ new Vector3( 1, 0, 0 ), /*@__PURE__*/ new Vector3( - 1, 0, 0 ), /*@__PURE__*/ new Vector3( 0, - 1, 0 ),
	/*@__PURE__*/ new Vector3( 0, 1, 0 ), /*@__PURE__*/ new Vector3( 0, 0, 1 ), /*@__PURE__*/ new Vector3( 0, 0, - 1 )
];

const _cubeUpsWebGPU = [
	/*@__PURE__*/ new Vector3( 0, - 1, 0 ), /*@__PURE__*/ new Vector3( 0, - 1, 0 ), /*@__PURE__*/ new Vector3( 0, 0, - 1 ),
	/*@__PURE__*/ new Vector3( 0, 0, 1 ), /*@__PURE__*/ new Vector3( 0, - 1, 0 ), /*@__PURE__*/ new Vector3( 0, - 1, 0 )
];

// WebGL coordinate system - standard OpenGL convention
const _cubeDirectionsWebGL = [
	/*@__PURE__*/ new Vector3( 1, 0, 0 ), /*@__PURE__*/ new Vector3( - 1, 0, 0 ), /*@__PURE__*/ new Vector3( 0, 1, 0 ),
	/*@__PURE__*/ new Vector3( 0, - 1, 0 ), /*@__PURE__*/ new Vector3( 0, 0, 1 ), /*@__PURE__*/ new Vector3( 0, 0, - 1 )
];

const _cubeUpsWebGL = [
	/*@__PURE__*/ new Vector3( 0, - 1, 0 ), /*@__PURE__*/ new Vector3( 0, - 1, 0 ), /*@__PURE__*/ new Vector3( 0, 0, 1 ),
	/*@__PURE__*/ new Vector3( 0, 0, - 1 ), /*@__PURE__*/ new Vector3( 0, - 1, 0 ), /*@__PURE__*/ new Vector3( 0, - 1, 0 )
];

export const BasicPointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp } ) => {

	return cubeTexture( depthTexture, bd3D ).compare( dp );

} );

/**
 * A shadow filtering function for point lights using Vogel disk sampling and IGN.
 *
 * Uses 5 samples distributed via Vogel disk pattern in tangent space around the
 * sample direction, rotated per-pixel using Interleaved Gradient Noise (IGN).
 *
 * @method
 * @param {Object} inputs - The input parameter object.
 * @param {CubeDepthTexture} inputs.depthTexture - A reference to the shadow cube map.
 * @param {Node<vec3>} inputs.bd3D - The normalized direction from light to fragment.
 * @param {Node<float>} inputs.dp - The depth value to compare against.
 * @param {LightShadow} inputs.shadow - The light shadow.
 * @return {Node<float>} The filtering result.
 */
export const PointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, shadow } ) => {

	const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );
	const mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );

	const texelSize = radius.div( mapSize.x );

	// Build a tangent-space coordinate system for applying offsets
	const absDir = abs( bd3D );
	const tangent = normalize( cross( bd3D, absDir.x.greaterThan( absDir.z ).select( vec3( 0, 1, 0 ), vec3( 1, 0, 0 ) ) ) );
	const bitangent = cross( bd3D, tangent );

	// Use IGN to rotate sampling pattern per pixel (phi = IGN * 2Ï€)
	const phi = interleavedGradientNoise( screenCoordinate.xy ).mul( 6.28318530718 );

	// 5 samples using Vogel disk distribution in tangent space
	const sample0 = vogelDiskSample( 0, 5, phi );
	const sample1 = vogelDiskSample( 1, 5, phi );
	const sample2 = vogelDiskSample( 2, 5, phi );
	const sample3 = vogelDiskSample( 3, 5, phi );
	const sample4 = vogelDiskSample( 4, 5, phi );

	return cubeTexture( depthTexture, bd3D.add( tangent.mul( sample0.x ).add( bitangent.mul( sample0.y ) ).mul( texelSize ) ) ).compare( dp )
		.add( cubeTexture( depthTexture, bd3D.add( tangent.mul( sample1.x ).add( bitangent.mul( sample1.y ) ).mul( texelSize ) ) ).compare( dp ) )
		.add( cubeTexture( depthTexture, bd3D.add( tangent.mul( sample2.x ).add( bitangent.mul( sample2.y ) ).mul( texelSize ) ) ).compare( dp ) )
		.add( cubeTexture( depthTexture, bd3D.add( tangent.mul( sample3.x ).add( bitangent.mul( sample3.y ) ).mul( texelSize ) ) ).compare( dp ) )
		.add( cubeTexture( depthTexture, bd3D.add( tangent.mul( sample4.x ).add( bitangent.mul( sample4.y ) ).mul( texelSize ) ) ).compare( dp ) )
		.mul( 1.0 / 5.0 );
=======
import { float, vec2, If, Fn, nodeObject } from '../tsl/TSLBase.js';
import { reference } from '../accessors/ReferenceNode.js';
import { texture } from '../accessors/TextureNode.js';
import { max, abs, sign } from '../math/MathNode.js';
import { sub, div } from '../math/OperatorNode.js';
import { renderGroup } from '../core/UniformGroupNode.js';
import { Vector2 } from '../../math/Vector2.js';
import { Vector4 } from '../../math/Vector4.js';
import { Color } from '../../math/Color.js';
import { BasicShadowMap } from '../../constants.js';

const _clearColor = /*@__PURE__*/ new Color();

// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
// vector suitable for 2D texture mapping. This code uses the following layout for the
// 2D texture:
//
// xzXZ
//  y Y
//
// Y - Positive y direction
// y - Negative y direction
// X - Positive x direction
// x - Negative x direction
// Z - Positive z direction
// z - Negative z direction
//
// Source and test bed:
// https://gist.github.com/tschw/da10c43c467ce8afd0c4

export const cubeToUV = /*@__PURE__*/ Fn( ( [ pos, texelSizeY ] ) => {

	const v = pos.toVar();

	// Number of texels to avoid at the edge of each square

	const absV = abs( v );

	// Intersect unit cube

	const scaleToCube = div( 1.0, max( absV.x, max( absV.y, absV.z ) ) );
	absV.mulAssign( scaleToCube );

	// Apply scale to avoid seams

	// two texels less per square (one texel will do for NEAREST)
	v.mulAssign( scaleToCube.mul( texelSizeY.mul( 2 ).oneMinus() ) );

	// Unwrap

	// space: -1 ... 1 range for each square
	//
	// #X##		dim    := ( 4 , 2 )
	//  # #		center := ( 1 , 1 )

	const planar = vec2( v.xy ).toVar();

	const almostATexel = texelSizeY.mul( 1.5 );
	const almostOne = almostATexel.oneMinus();

	If( absV.z.greaterThanEqual( almostOne ), () => {

		If( v.z.greaterThan( 0.0 ), () => {

			planar.x.assign( sub( 4.0, v.x ) );

		} );

	} ).ElseIf( absV.x.greaterThanEqual( almostOne ), () => {

		const signX = sign( v.x );
		planar.x.assign( v.z.mul( signX ).add( signX.mul( 2.0 ) ) );

	} ).ElseIf( absV.y.greaterThanEqual( almostOne ), () => {

		const signY = sign( v.y );
		planar.x.assign( v.x.add( signY.mul( 2.0 ) ).add( 2.0 ) );
		planar.y.assign( v.z.mul( signY ).sub( 2.0 ) );

	} );

	// Transform to UV space

	// scale := 0.5 / dim
	// translate := ( center + 0.5 ) / dim
	return vec2( 0.125, 0.25 ).mul( planar ).add( vec2( 0.375, 0.75 ) ).flipY();

} ).setLayout( {
	name: 'cubeToUV',
	type: 'vec2',
	inputs: [
		{ name: 'pos', type: 'vec3' },
		{ name: 'texelSizeY', type: 'float' }
	]
} );

export const BasicPointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize } ) => {

	return texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp );

} );

export const PointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize, shadow } ) => {

	const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );
	const offset = vec2( - 1.0, 1.0 ).mul( radius ).mul( texelSize.y );

	return texture( depthTexture, cubeToUV( bd3D.add( offset.xyy ), texelSize.y ) ).compare( dp )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyy ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xyx ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyx ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxy ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxy ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxx ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxx ), texelSize.y ) ).compare( dp ) )
		.mul( 1.0 / 9.0 );
>>>>>>> f5f1c0941585b2a74e09a97a7709c50c3a364a48

} );

const pointShadowFilter = /*@__PURE__*/ Fn( ( { filterFn, depthTexture, shadowCoord, shadow } ) => {

	// for point lights, the uniform @vShadowCoord is re-purposed to hold
	// the vector from the light to the world-space position of the fragment.
	const lightToPosition = shadowCoord.xyz.toVar();
	const lightToPositionLength = lightToPosition.length();

	const cameraNearLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.near );
	const cameraFarLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.far );
	const bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );
<<<<<<< HEAD
=======
	const mapSize = uniform( shadow.mapSize ).setGroup( renderGroup );
>>>>>>> f5f1c0941585b2a74e09a97a7709c50c3a364a48

	const result = float( 1.0 ).toVar();

	If( lightToPositionLength.sub( cameraFarLocal ).lessThanEqual( 0.0 ).and( lightToPositionLength.sub( cameraNearLocal ).greaterThanEqual( 0.0 ) ), () => {

		// dp = normalized distance from light to fragment position
		const dp = lightToPositionLength.sub( cameraNearLocal ).div( cameraFarLocal.sub( cameraNearLocal ) ).toVar(); // need to clamp?
		dp.addAssign( bias );

<<<<<<< HEAD
		// bd3D = base direction 3D (direction from light to fragment)
		const bd3D = lightToPosition.normalize();

		// percentage-closer filtering using cube texture sampling
		result.assign( filterFn( { depthTexture, bd3D, dp, shadow } ) );
=======
		// bd3D = base direction 3D
		const bd3D = lightToPosition.normalize();
		const texelSize = vec2( 1.0 ).div( mapSize.mul( vec2( 4.0, 2.0 ) ) );

		// percentage-closer filtering
		result.assign( filterFn( { depthTexture, bd3D, dp, texelSize, shadow } ) );
>>>>>>> f5f1c0941585b2a74e09a97a7709c50c3a364a48

	} );

	return result;

} );

<<<<<<< HEAD
=======
const _viewport = /*@__PURE__*/ new Vector4();
const _viewportSize = /*@__PURE__*/ new Vector2();
const _shadowMapSize = /*@__PURE__*/ new Vector2();

>>>>>>> f5f1c0941585b2a74e09a97a7709c50c3a364a48

/**
 * Represents the shadow implementation for point light nodes.
 *
 * @augments ShadowNode
 */
class PointShadowNode extends ShadowNode {

	static get type() {

		return 'PointShadowNode';

	}

	/**
	 * Constructs a new point shadow node.
	 *
	 * @param {PointLight} light - The shadow casting point light.
	 * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.
	 */
	constructor( light, shadow = null ) {

		super( light, shadow );

	}

	/**
	 * Overwrites the default implementation to return point light shadow specific
	 * filtering functions.
	 *
	 * @param {number} type - The shadow type.
	 * @return {Function} The filtering function.
	 */
	getShadowFilterFn( type ) {

		return type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;

	}

	/**
	 * Overwrites the default implementation so the unaltered shadow position is used.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
	 * @return {Node<vec3>} The shadow coordinates.
	 */
	setupShadowCoord( builder, shadowPosition ) {

		return shadowPosition;

	}

	/**
	 * Overwrites the default implementation to only use point light specific
	 * shadow filter functions.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @param {Object} inputs - A configuration object that defines the shadow filtering.
	 * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
<<<<<<< HEAD
	 * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's depth texture.
=======
	 * @param {Texture} inputs.shadowTexture - A reference to the shadow map's texture.
	 * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
>>>>>>> f5f1c0941585b2a74e09a97a7709c50c3a364a48
	 * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
	 * @param {LightShadow} inputs.shadow - The light shadow.
	 * @return {Node<float>} The result node of the shadow filtering.
	 */
<<<<<<< HEAD
	setupShadowFilter( builder, { filterFn, depthTexture, shadowCoord, shadow } ) {

		return pointShadowFilter( { filterFn, depthTexture, shadowCoord, shadow } );

	}

	/**
	 * Overwrites the default implementation to create a CubeRenderTarget with CubeDepthTexture.
	 *
	 * @param {LightShadow} shadow - The light shadow object.
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @return {Object} An object containing the shadow map and depth texture.
	 */
	setupRenderTarget( shadow, builder ) {

		const depthTexture = new CubeDepthTexture( shadow.mapSize.width );
		depthTexture.name = 'PointShadowDepthTexture';
		depthTexture.compareFunction = LessCompare;

		const shadowMap = builder.createCubeRenderTarget( shadow.mapSize.width );
		shadowMap.texture.name = 'PointShadowMap';
		shadowMap.depthTexture = depthTexture;

		return { shadowMap, depthTexture };
=======
	setupShadowFilter( builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } ) {

		return pointShadowFilter( { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } );
>>>>>>> f5f1c0941585b2a74e09a97a7709c50c3a364a48

	}

	/**
	 * Overwrites the default implementation with point light specific
	 * rendering code.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	renderShadow( frame ) {

		const { shadow, shadowMap, light } = this;
		const { renderer, scene } = frame;

<<<<<<< HEAD
		const camera = shadow.camera;
		const shadowMatrix = shadow.matrix;

		// Select cube directions/ups based on coordinate system
		const isWebGPU = renderer.coordinateSystem === WebGPUCoordinateSystem;
		const cubeDirections = isWebGPU ? _cubeDirectionsWebGPU : _cubeDirectionsWebGL;
		const cubeUps = isWebGPU ? _cubeUpsWebGPU : _cubeUpsWebGL;

		shadowMap.setSize( shadow.mapSize.width, shadow.mapSize.width );
=======
		const shadowFrameExtents = shadow.getFrameExtents();

		_shadowMapSize.copy( shadow.mapSize );
		_shadowMapSize.multiply( shadowFrameExtents );

		shadowMap.setSize( _shadowMapSize.width, _shadowMapSize.height );

		_viewportSize.copy( shadow.mapSize );
>>>>>>> f5f1c0941585b2a74e09a97a7709c50c3a364a48

		//

		const previousAutoClear = renderer.autoClear;

		const previousClearColor = renderer.getClearColor( _clearColor );
		const previousClearAlpha = renderer.getClearAlpha();

		renderer.autoClear = false;
		renderer.setClearColor( shadow.clearColor, shadow.clearAlpha );
<<<<<<< HEAD

		// Render each cube face
		for ( let face = 0; face < 6; face ++ ) {

			// Set render target to the specific cube face
			renderer.setRenderTarget( shadowMap, face );
			renderer.clear();

			// Update shadow camera matrices for this face

			const far = light.distance || camera.far;

			if ( far !== camera.far ) {

				camera.far = far;
				camera.updateProjectionMatrix();

			}

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			camera.position.copy( _lightPositionWorld );

			_lookTarget.copy( camera.position );
			_lookTarget.add( cubeDirections[ face ] );
			camera.up.copy( cubeUps[ face ] );
			camera.lookAt( _lookTarget );
			camera.updateMatrixWorld();

			shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			shadow._frustum.setFromProjectionMatrix( _projScreenMatrix, camera.coordinateSystem, camera.reversedDepth );

			//

			const currentSceneName = scene.name;

			scene.name = `Point Light Shadow [ ${ light.name || 'ID: ' + light.id } ] - Face ${ face + 1 }`;

			renderer.render( scene, camera );

			scene.name = currentSceneName;
=======
		renderer.clear();

		const viewportCount = shadow.getViewportCount();

		for ( let vp = 0; vp < viewportCount; vp ++ ) {

			const viewport = shadow.getViewport( vp );

			const x = _viewportSize.x * viewport.x;
			const y = _shadowMapSize.y - _viewportSize.y - ( _viewportSize.y * viewport.y );

			_viewport.set(
				x,
				y,
				_viewportSize.x * viewport.z,
				_viewportSize.y * viewport.w
			);

			shadowMap.viewport.copy( _viewport );

			shadow.updateMatrices( light, vp );

			renderer.render( scene, shadow.camera );
>>>>>>> f5f1c0941585b2a74e09a97a7709c50c3a364a48

		}

		//

		renderer.autoClear = previousAutoClear;
		renderer.setClearColor( previousClearColor, previousClearAlpha );

	}

}

export default PointShadowNode;

/**
 * TSL function for creating an instance of `PointShadowNode`.
 *
 * @tsl
 * @function
 * @param {PointLight} light - The shadow casting point light.
 * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.
 * @return {PointShadowNode} The created point shadow node.
 */
<<<<<<< HEAD
export const pointShadow = ( light, shadow ) => new PointShadowNode( light, shadow );
=======
export const pointShadow = ( light, shadow ) => nodeObject( new PointShadowNode( light, shadow ) );
>>>>>>> f5f1c0941585b2a74e09a97a7709c50c3a364a48
